

{% extends "base.html" %}
{% block title %}Site Structure Visualization - Web Analyzer Pro{% endblock %}
{% block content %}
<style>
    /* Enhanced Visualization Styles - Following base.html patterns */
    .viz-app {
        display: flex;
        height: calc(100vh - var(--header-height, 70px));
        width: 100%;
        position: relative;
        background-color: var(--background);
        overflow: hidden;
    }

    /* Desktop Control Panel - Hidden on mobile like base.html sidebar */
    .viz-control-panel {
        width: 320px;
        background-color: var(--surface);
        border-right: 1px solid rgba(0, 0, 0, 0.05);
        display: flex;
        flex-direction: column;
        overflow-y: auto;
        transition: transform var(--transition-speed) cubic-bezier(0.4, 0, 0.2, 1);
        position: relative;
        box-shadow: var(--shadow-md);
        z-index: 90;
        scrollbar-width: thin;
        scrollbar-color: var(--primary-light) transparent;
    }

    .viz-control-panel::-webkit-scrollbar {
        width: 0.375rem;
    }

    .viz-control-panel::-webkit-scrollbar-track {
        background: transparent;
    }

    .viz-control-panel::-webkit-scrollbar-thumb {
        background-color: var(--primary-light);
        border-radius: 0.625rem;
    }

    .viz-control-panel.collapsed {
        transform: translateX(-280px);
    }

    /* Panel Toggle Button - Following base.html toggle button style */
    .panel-toggle {
        position: absolute;
        right: -40px;
        top: 50%;
        transform: translateY(-50%);
        width: 40px;
        height: 60px;
        background-color: var(--surface);
        border: 1px solid rgba(0, 0, 0, 0.05);
        border-left: none;
        border-radius: 0 var(--border-radius) var(--border-radius) 0;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        box-shadow: var(--shadow-sm);
        transition: all var(--transition-speed);
        z-index: 91;
        min-width: 44px;
        min-height: 44px;
    }

    .panel-toggle::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        border-radius: 0 var(--border-radius) var(--border-radius) 0;
        transform: scale(0);
        transition: transform 0.5s ease;
    }

    .panel-toggle:hover::before {
        transform: scale(1);
    }

    .panel-toggle:hover {
        background-color: var(--background);
        color: var(--primary);
        transform: translateY(-50%) scale(1.05);
    }

    .panel-toggle svg {
        width: 20px;
        height: 20px;
        transition: transform var(--transition-speed);
    }

    .viz-control-panel.collapsed .panel-toggle svg {
        transform: rotate(180deg);
    }

    /* Enhanced Mobile Control Header - Following base.html mobile nav patterns */
    .mobile-viz-header {
        display: none;
        background-color: var(--surface);
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        padding: 1rem;
        box-shadow: var(--shadow-sm);
        z-index: 100;
        position: relative;
    }

    .mobile-viz-title {
        font-size: 1.25rem;
        font-weight: 700;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 1rem;
        text-align: center;
    }

    .mobile-viz-controls {
        display: grid;
        grid-template-columns: 1fr auto auto;
        gap: 0.75rem;
        align-items: center;
        margin-bottom: 1rem;
    }

    .mobile-control-group {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }

    /* Enhanced Mobile Controls - Following base.html button patterns */
    .mobile-control-select {
        padding: 0.75rem 1rem;
        border: 2px solid #e2e8f0;
        border-radius: var(--border-radius);
        font-size: 0.875rem;
        background-color: var(--surface);
        cursor: pointer;
        transition: all var(--transition-speed);
        min-height: 44px;
        flex: 1;
        -webkit-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
        padding-right: 2.5rem;
    }

    .mobile-control-select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
    }

    .mobile-control-btn {
        padding: 0.75rem;
        border: none;
        border-radius: var(--border-radius);
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        color: white;
        cursor: pointer;
        transition: all var(--transition-speed);
        display: flex;
        align-items: center;
        justify-content: center;
        min-width: 44px;
        min-height: 44px;
        font-size: 0.875rem;
        position: relative;
        overflow: hidden;
    }

    .mobile-control-btn::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        transition: transform 0.5s ease;
        transform: skewX(-15deg);
    }

    .mobile-control-btn:hover::before,
    .mobile-control-btn:active::before {
        transform: translateX(200%) skewX(-15deg);
    }

    .mobile-control-btn:hover,
    .mobile-control-btn:active {
        opacity: 0.95;
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
    }

    .mobile-control-btn.secondary {
        background: var(--surface);
        color: var(--text);
        border: 2px solid var(--primary);
    }

    .mobile-control-btn.secondary:hover {
        background: var(--primary);
        color: white;
    }

    .mobile-control-btn.outline {
        background: transparent;
        border: 2px solid var(--primary);
        color: var(--primary);
    }

    .mobile-control-btn.outline:hover {
        background: var(--primary);
        color: white;
    }

    /* Enhanced Mobile Search Container */
    .mobile-search-container {
        opacity: 0;
        max-height: 0;
        overflow: hidden;
        transition: all var(--transition-speed) cubic-bezier(0.4, 0, 0.2, 1);
        transform: translateY(-10px);
    }

    .mobile-search-container.active {
        opacity: 1;
        max-height: 100px;
        transform: translateY(0);
        margin-top: 0.75rem;
    }

    /* Enhanced Sliders for Mobile */
    .mobile-slider-group {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        margin-top: 1rem;
        padding: 1rem;
        background: rgba(79, 70, 229, 0.05);
        border-radius: var(--border-radius);
        border: 1px solid rgba(79, 70, 229, 0.1);
    }

    .mobile-slider-control {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
    }

    .mobile-slider-label {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text);
        text-align: center;
    }

    .mobile-slider-input {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: #e2e8f0;
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
    }

    .mobile-slider-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        cursor: pointer;
        transition: all var(--transition-speed);
        border: 2px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .mobile-slider-input::-webkit-slider-thumb:hover,
    .mobile-slider-input::-webkit-slider-thumb:active {
        transform: scale(1.2);
        box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
    }

    .mobile-slider-value {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--primary);
        text-align: center;
    }

    /* Main Visualization Container */
    .viz-container {
        flex: 1;
        position: relative;
        overflow: hidden;
        background-color: var(--background);
        background-image: 
            radial-gradient(circle at 1px 1px, rgba(79, 70, 229, 0.05) 1px, transparent 1px);
        background-size: 20px 20px;
        touch-action: none;
    }

    /* Enhanced Control Panel Sections - Following base.html nav patterns */
    .viz-panel-header {
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        background: linear-gradient(to right, rgba(249, 250, 251, 0.8), rgba(255, 255, 255, 0.8));
    }

    .viz-panel-header h1 {
        font-size: 1.5rem;
        font-weight: 700;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        margin-bottom: 0.5rem;
    }

    .viz-panel-header p {
        font-size: 0.875rem;
        color: var(--text-light);
        line-height: 1.6;
    }

    .viz-control-section {
        padding: 1.5rem;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        transition: background-color var(--transition-speed);
    }

    .viz-control-section:hover {
        background-color: rgba(79, 70, 229, 0.02);
    }

    .viz-section-title {
        font-size: 0.75rem;
        font-weight: 600;
        color: var(--text-light);
        text-transform: uppercase;
        letter-spacing: 0.5px;
        margin-bottom: 1rem;
        position: relative;
        padding-bottom: 0.5rem;
    }

    .viz-section-title::after {
        content: '';
        position: absolute;
        left: 0;
        bottom: 0;
        width: 2rem;
        height: 0.125rem;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        border-radius: var(--border-radius);
    }

    /* Enhanced Search Box */
    .viz-search-box {
        position: relative;
        margin-bottom: 1rem;
    }

    .viz-search-input {
        width: 100%;
        padding: 0.75rem 1rem;
        padding-left: 36px;
        border: 2px solid #e2e8f0;
        border-radius: var(--border-radius);
        font-size: 0.875rem;
        background-color: var(--surface);
        transition: all var(--transition-speed);
        min-height: 44px;
        -webkit-appearance: none;
    }

    .viz-search-input:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        transform: translateY(-1px);
    }

    .viz-search-input::placeholder {
        color: var(--text-light);
        opacity: 0.8;
    }

    .viz-search-icon {
        position: absolute;
        left: 12px;
        top: 50%;
        transform: translateY(-50%);
        width: 16px;
        height: 16px;
        opacity: 0.5;
        color: var(--text-light);
        pointer-events: none;
        transition: all var(--transition-speed);
    }

    .viz-search-input:focus + .viz-search-icon {
        color: var(--primary);
        opacity: 1;
    }

    /* Enhanced Control Buttons - Following base.html btn patterns */
    .viz-control-button {
        width: 100%;
        padding: 0.75rem 1.25rem;
        border: none;
        border-radius: var(--border-radius);
        font-size: 0.875rem;
        font-weight: 600;
        background-color: var(--surface);
        color: var(--text);
        cursor: pointer;
        transition: all var(--transition-speed);
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.5rem;
        text-decoration: none;
        box-shadow: var(--shadow-sm);
        position: relative;
        overflow: hidden;
        min-height: 44px;
        user-select: none;
        -webkit-tap-highlight-color: transparent;
        border: 2px solid transparent;
    }

    .viz-control-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: rgba(255, 255, 255, 0.2);
        transition: transform 0.5s ease;
        transform: skewX(-15deg);
    }

    .viz-control-button:hover::before,
    .viz-control-button:active::before {
        transform: translateX(200%) skewX(-15deg);
    }

    .viz-control-button:hover,
    .viz-control-button:active {
        background-color: var(--background);
        color: var(--primary);
        transform: translateY(-1px);
        box-shadow: var(--shadow-md);
        border-color: rgba(79, 70, 229, 0.1);
    }

    .viz-control-button.primary {
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        color: white;
        border-color: transparent;
    }

    .viz-control-button.primary:hover,
    .viz-control-button.primary:active {
        opacity: 0.95;
        transform: translateY(-1px);
        color: white;
    }

    /* Enhanced Control Grid */
    .viz-control-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 0.75rem;
        margin-bottom: 1rem;
    }

    /* Enhanced Select Dropdown */
    .viz-control-select {
        width: 100%;
        padding: 0.75rem 1rem;
        border: 2px solid #e2e8f0;
        border-radius: var(--border-radius);
        font-size: 0.875rem;
        background-color: var(--surface);
        cursor: pointer;
        transition: all var(--transition-speed);
        min-height: 44px;
        -webkit-appearance: none;
        appearance: none;
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3e%3cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='m6 8 4 4 4-4'/%3e%3c/svg%3e");
        background-position: right 0.5rem center;
        background-repeat: no-repeat;
        background-size: 1.5em 1.5em;
        padding-right: 2.5rem;
    }

    .viz-control-select:focus {
        outline: none;
        border-color: var(--primary);
        box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        transform: translateY(-1px);
    }

    /* Enhanced Slider Control */
    .viz-slider-control {
        margin-bottom: 1rem;
    }

    .viz-slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.5rem;
        font-size: 0.875rem;
        color: var(--text);
    }

    .viz-slider-value {
        font-weight: 600;
        color: var(--primary);
        background: rgba(79, 70, 229, 0.1);
        padding: 0.25rem 0.5rem;
        border-radius: var(--border-radius);
        font-size: 0.75rem;
    }

    .viz-slider-input {
        width: 100%;
        height: 8px;
        border-radius: 4px;
        background: linear-gradient(to right, var(--primary) 0%, var(--primary) var(--slider-progress, 50%), #e2e8f0 var(--slider-progress, 50%), #e2e8f0 100%);
        outline: none;
        -webkit-appearance: none;
        cursor: pointer;
        transition: all var(--transition-speed);
    }

    .viz-slider-input::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        cursor: pointer;
        transition: all var(--transition-speed);
        border: 3px solid white;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    .viz-slider-input::-webkit-slider-thumb:hover,
    .viz-slider-input::-webkit-slider-thumb:active {
        transform: scale(1.2);
        box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
    }

    /* Enhanced Legend Section */
    .viz-legend-grid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 1rem;
    }

    .viz-legend-group {
        background: linear-gradient(135deg, rgba(79, 70, 229, 0.05), rgba(14, 165, 233, 0.05));
        border-radius: var(--border-radius);
        padding: 1rem;
        border: 1px solid rgba(79, 70, 229, 0.1);
        transition: all var(--transition-speed);
    }

    .viz-legend-group:hover {
        transform: translateY(-2px);
        box-shadow: var(--shadow-md);
        border-color: rgba(79, 70, 229, 0.2);
    }

    .viz-legend-title {
        font-size: 0.8rem;
        font-weight: 600;
        color: var(--text);
        margin-bottom: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .viz-legend-item {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        margin-bottom: 0.5rem;
        font-size: 0.8rem;
        color: var(--text);
        padding: 0.5rem;
        border-radius: var(--border-radius);
        transition: all var(--transition-speed);
    }

    .viz-legend-item:hover {
        background: rgba(255, 255, 255, 0.5);
        transform: translateX(0.25rem);
    }

    .viz-legend-color {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 2px solid rgba(0, 0, 0, 0.1);
        flex-shrink: 0;
        transition: all var(--transition-speed);
    }

    .viz-legend-item:hover .viz-legend-color {
        transform: scale(1.2);
        border-color: rgba(0, 0, 0, 0.2);
    }

    /* SVG Container */
    #visualization {
        width: 100%;
        height: 100%;
        cursor: grab;
        touch-action: none;
    }

    #visualization:active {
        cursor: grabbing;
    }

    /* Enhanced Node and Link Styles */
    .node {
        cursor: pointer;
        transition: all var(--transition-speed);
    }

    .node circle {
        stroke-width: 3px;
        transition: all var(--transition-speed);
        filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
    }

    .node:hover circle {
        stroke-width: 5px;
        filter: drop-shadow(0 4px 8px rgba(79, 70, 229, 0.3));
        transform: scale(1.1);
    }

    .node.highlighted circle {
        stroke-width: 5px;
        filter: drop-shadow(0 4px 12px rgba(79, 70, 229, 0.5));
        transform: scale(1.15);
    }

    .node.selected circle {
        stroke: var(--primary);
        stroke-width: 5px;
        filter: drop-shadow(0 4px 12px rgba(79, 70, 229, 0.6));
    }

    .node text {
        font-size: 13px;
        font-weight: 500;
        fill: var(--text);
        pointer-events: none;
        user-select: none;
        transition: all var(--transition-speed);
        text-shadow: 0 1px 2px rgba(255, 255, 255, 0.8);
    }

    .node.highlighted text {
        font-weight: 600;
        font-size: 14px;
        fill: var(--primary);
    }

    .link {
        fill: none;
        stroke: var(--text-light);
        stroke-width: 1.5px;
        stroke-opacity: 0.3;
        transition: all var(--transition-speed);
    }

    .link.highlighted {
        stroke: var(--primary);
        stroke-width: 3px;
        stroke-opacity: 0.8;
        filter: drop-shadow(0 1px 2px rgba(79, 70, 229, 0.2));
    }

    /* Enhanced Node Info Panel */
    .viz-node-info {
        position: absolute;
        top: 1rem;
        right: 1rem;
        width: 320px;
        max-width: calc(100vw - 2rem);
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.95), rgba(248, 250, 252, 0.95));
        backdrop-filter: blur(10px);
        border-radius: var(--border-radius);
        box-shadow: var(--shadow-lg);
        padding: 1.5rem;
        transform: translateX(400px);
        transition: transform var(--transition-speed) cubic-bezier(0.4, 0, 0.2, 1);
        z-index: 50;
        max-height: calc(100vh - 2rem);
        overflow-y: auto;
        border: 1px solid rgba(79, 70, 229, 0.1);
    }

    .viz-node-info.visible {
        transform: translateX(0);
    }

    .viz-node-info-header {
        display: flex;
        justify-content: space-between;
        align-items: start;
        margin-bottom: 1.5rem;
        gap: 1rem;
        padding-bottom: 1rem;
        border-bottom: 2px solid rgba(79, 70, 229, 0.1);
    }

    .viz-node-info-title {
        font-size: 1.125rem;
        font-weight: 600;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        word-break: break-word;
        flex: 1;
        line-height: 1.4;
    }

    .viz-node-info-close {
        width: 36px;
        height: 36px;
        border: 2px solid rgba(79, 70, 229, 0.2);
        background: rgba(79, 70, 229, 0.05);
        cursor: pointer;
        opacity: 0.8;
        transition: all var(--transition-speed);
        flex-shrink: 0;
        color: var(--text);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        -webkit-tap-highlight-color: transparent;
    }

    .viz-node-info-close:hover,
    .viz-node-info-close:active {
        opacity: 1;
        background: var(--primary);
        color: white;
        border-color: var(--primary);
        transform: scale(1.1);
    }

    .viz-node-info-row {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 0;
        border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        font-size: 0.875rem;
        gap: 1rem;
        transition: all var(--transition-speed);
    }

    .viz-node-info-row:hover {
        background: rgba(79, 70, 229, 0.02);
        margin: 0 -0.5rem;
        padding-left: 0.5rem;
        padding-right: 0.5rem;
        border-radius: var(--border-radius);
    }

    .viz-node-info-label {
        color: var(--text-light);
        font-weight: 600;
        flex-shrink: 0;
        font-size: 0.75rem;
        text-transform: uppercase;
        letter-spacing: 0.5px;
    }

    .viz-node-info-value {
        color: var(--text);
        text-align: right;
        word-break: break-word;
        flex: 1;
        font-weight: 500;
    }

    /* Enhanced Status Badges */
    .viz-status-badge {
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        padding: 0.375rem 0.75rem;
        border-radius: 1rem;
        font-size: 0.75rem;
        font-weight: 600;
        color: white;
        text-transform: uppercase;
        letter-spacing: 0.5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .viz-status-success { 
        background: linear-gradient(45deg, #10b981, #059669);
    }
    .viz-status-warning { 
        background: linear-gradient(45deg, #f59e0b, #d97706);
    }
    .viz-status-danger { 
        background: linear-gradient(45deg, #ef4444, #dc2626);
    }
    .viz-status-info { 
        background: linear-gradient(45deg, var(--accent), var(--secondary));
    }
    .viz-status-unknown { 
        background: linear-gradient(45deg, var(--text-light), #64748b);
    }

    /* Enhanced Zoom Controls */
    .viz-zoom-controls {
        position: absolute;
        bottom: 1rem;
        right: 1rem;
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        z-index: 40;
    }

    .viz-zoom-button {
        width: 48px;
        height: 48px;
        background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(248, 250, 252, 0.9));
        backdrop-filter: blur(10px);
        border: 2px solid rgba(79, 70, 229, 0.2);
        border-radius: 50%;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        box-shadow: var(--shadow-md);
        transition: all var(--transition-speed);
        color: var(--text);
        font-size: 1.25rem;
        -webkit-tap-highlight-color: transparent;
        position: relative;
        overflow: hidden;
    }

    .viz-zoom-button::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(45deg, var(--primary), var(--secondary));
        opacity: 0;
        transition: opacity var(--transition-speed);
        border-radius: 50%;
    }

    .viz-zoom-button:hover::before,
    .viz-zoom-button:active::before {
        opacity: 1;
    }

    .viz-zoom-button:hover,
    .viz-zoom-button:active {
        color: white;
        transform: translateY(-2px) scale(1.05);
        box-shadow: var(--shadow-lg);
        border-color: var(--primary);
    }

    .viz-zoom-button i {
        position: relative;
        z-index: 1;
    }

    /* Enhanced Loading Overlay */
    .viz-loading-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(5px);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity var(--transition-speed);
    }

    .viz-loading-overlay.hidden {
        opacity: 0;
        pointer-events: none;
    }

    .viz-loading-spinner {
        width: 48px;
        height: 48px;
        border: 3px solid var(--primary-light);
        border-top-color: var(--primary);
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        margin-bottom: 1rem;
        box-shadow: 0 0 20px rgba(79, 70, 229, 0.3);
    }

    .viz-loading-text {
        font-size: 0.875rem;
        color: var(--text-light);
        font-weight: 500;
    }

    /* Enhanced Tooltip */
    .viz-tooltip {
        position: absolute;
        background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(51, 65, 85, 0.95));
        backdrop-filter: blur(10px);
        color: white;
        padding: 0.75rem 1rem;
        border-radius: var(--border-radius);
        font-size: 0.875rem;
        pointer-events: none;
        opacity: 0;
        transition: opacity var(--transition-speed);
        z-index: 1000;
        max-width: 280px;
        box-shadow: var(--shadow-lg);
        border: 1px solid rgba(255, 255, 255, 0.1);
    }

    .viz-tooltip.visible {
        opacity: 1;
    }

    .viz-tooltip::before {
        content: '';
        position: absolute;
        bottom: 100%;
        left: 50%;
        transform: translateX(-50%);
        border-width: 0 8px 8px 8px;
        border-style: solid;
        border-color: transparent transparent rgba(30, 41, 59, 0.95) transparent;
    }

    /* RESPONSIVE STYLES - Following base.html patterns */
    @media (max-width: 1024px) {
        .viz-control-panel {
            width: 280px;
        }
        
        .viz-node-info {
            width: 280px;
        }
    }

    /* MOBILE STYLES - Key Changes Here */
    @media (max-width: 768px) {
        .viz-app {
            flex-direction: column;
            height: calc(100vh - var(--header-height, 60px));
        }

        /* HIDE DESKTOP CONTROL PANEL ON MOBILE */
        .viz-control-panel {
            display: none !important;
        }

        /* SHOW MOBILE HEADER */
        .mobile-viz-header {
            display: block;
        }

        .viz-container {
            flex: 1;
            background-size: 15px 15px;
        }
        
        .viz-node-info {
            top: 0.5rem;
            right: 0.5rem;
            left: 0.5rem;
            width: auto;
            max-width: none;
            max-height: calc(100vh - 1rem);
            transform: translateY(-100vh);
        }

        .viz-node-info.visible {
            transform: translateY(0);
        }
        
        .viz-zoom-controls {
            bottom: 1rem;
            right: 1rem;
            flex-direction: row;
            gap: 0.5rem;
        }

        .viz-zoom-button {
            width: 44px;
            height: 44px;
            font-size: 1rem;
        }

        /* Enhanced Mobile Controls Layout */
        .mobile-viz-controls {
            grid-template-columns: 1fr auto;
            gap: 0.5rem;
        }

        .mobile-control-group {
            gap: 0.5rem;
        }

        /* Better mobile node interaction */
        .node circle {
            stroke-width: 4px;
        }

        .node text {
            font-size: 14px;
            text-shadow: 0 1px 3px rgba(255, 255, 255, 0.9);
        }

        /* Hide tooltips on mobile */
        .viz-tooltip {
            display: none;
        }

        /* Mobile slider adjustments */
        .mobile-slider-group {
            grid-template-columns: 1fr;
            gap: 0.75rem;
        }

        .mobile-slider-control {
            background: rgba(255, 255, 255, 0.8);
            padding: 0.75rem;
            border-radius: var(--border-radius);
            border: 1px solid rgba(79, 70, 229, 0.1);
        }
    }

    @media (max-width: 480px) {
        .mobile-viz-header {
            padding: 0.75rem;
        }

        .mobile-viz-title {
            font-size: 1.1rem;
            margin-bottom: 0.75rem;
        }

        .mobile-viz-controls {
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }

        .mobile-control-group {
            width: 100%;
            justify-content: space-between;
        }

        .mobile-control-select {
            min-width: 100px;
            flex: 1;
        }

        .viz-node-info {
            padding: 1rem;
        }

        .viz-node-info-title {
            font-size: 1rem;
        }

        .viz-zoom-controls {
            bottom: 0.5rem;
            right: 0.5rem;
        }

        .viz-zoom-button {
            width: 40px;
            height: 40px;
            font-size: 0.875rem;
        }

        /* Improved mobile slider layout */
        .mobile-slider-group {
            padding: 0.75rem;
        }

        .mobile-slider-input::-webkit-slider-thumb {
            width: 18px;
            height: 18px;
        }
    }

    /* High DPI displays */
    @media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {
        .viz-legend-color {
            border-width: 1px;
        }
        
        .node circle {
            stroke-width: 2px;
        }
        
        .node:hover circle {
            stroke-width: 3px;
        }
    }

    /* Reduce motion for accessibility */
    @media (prefers-reduced-motion: reduce) {
        * {
            transition-duration: 0.1s !important;
            animation-duration: 0.1s !important;
        }
        
        .viz-loading-spinner {
            animation: none;
            border: 3px solid var(--primary);
        }
    }

    /* Dark mode adjustments */
    @media (prefers-color-scheme: dark) {
        .viz-loading-overlay {
            background-color: rgba(0, 0, 0, 0.9);
        }
        
        .viz-node-info {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.95), rgba(51, 65, 85, 0.95));
            color: #f8fafc;
        }
        
        .viz-zoom-button {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(51, 65, 85, 0.9));
            color: #f8fafc;
        }
    }

    /* Animation keyframes */
    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    @keyframes fadeInUp {
        from {
            opacity: 0;
            transform: translateY(1.25rem);
        }
        to {
            opacity: 1;
            transform: translateY(0);
        }
    }

    @keyframes pulse {
        0%, 100% {
            opacity: 1;
        }
        50% {
            opacity: 0.5;
        }
    }

    .animate-fade-in {
        animation: fadeInUp 0.6s ease forwards;
    }

    .animate-pulse {
        animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
    }
</style>

<div class="animate-fade-in">
    <!-- Enhanced Mobile Control Header -->
    <div class="mobile-viz-header">
        <h2 class="mobile-viz-title">
            <i class="fas fa-sitemap" style="margin-right: 0.5rem;"></i>
            Site Structure Visualization
        </h2>
        
        <div class="mobile-viz-controls">
            <select id="mobileLayoutSelect" class="mobile-control-select" aria-label="Layout Type">
                <option value="radial">üåê Radial Layout</option>
                <option value="tree">üå≥ Tree Layout</option>
                <option value="cluster">üîó Cluster Layout</option>
            </select>
            
            <div class="mobile-control-group">
                <button class="mobile-control-btn outline" onclick="toggleMobileSearch()" aria-label="Toggle Search" title="Search Nodes">
                    <i class="fas fa-search"></i>
                </button>
                <button class="mobile-control-btn secondary" onclick="toggleMobileControls()" aria-label="Toggle Controls" title="More Controls">
                    <i class="fas fa-sliders-h"></i>
                </button>
            </div>
        </div>
        
        <!-- Enhanced Mobile Search -->
        <div class="mobile-search-container" id="mobileSearchContainer">
            <div class="viz-search-box">
                <input type="text" 
                       class="viz-search-input" 
                       id="mobileSearchInput" 
                       placeholder="Search nodes by name or URL..."
                       autocomplete="off"
                       aria-label="Search nodes">
                <svg class="viz-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <circle cx="11" cy="11" r="8"></circle>
                    <path d="m21 21-4.35-4.35"></path>
                </svg>
            </div>
        </div>

        <!-- Enhanced Mobile Sliders -->
        <div class="mobile-slider-group" id="mobileSliderGroup" style="display: none;">
            <div class="mobile-slider-control">
                <div class="mobile-slider-label">Node Distance</div>
                <input type="range" 
                       class="mobile-slider-input"
                       id="mobileDistanceSlider" 
                       min="40" 
                       max="200" 
                       value="80"
                       aria-label="Node Distance">
                <div class="mobile-slider-value" id="mobileDistanceValue">80</div>
            </div>
            <div class="mobile-slider-control">
                <div class="mobile-slider-label">Node Size</div>
                <input type="range" 
                       class="mobile-slider-input"
                       id="mobileSizeSlider" 
                       min="50" 
                       max="150" 
                       value="100"
                       aria-label="Node Size">
                <div class="mobile-slider-value" id="mobileSizeValue">100%</div>
            </div>
        </div>

        <!-- Mobile Action Buttons -->
        <div class="mobile-viz-controls" style="margin-top: 1rem; grid-template-columns: repeat(4, 1fr);">
            <button class="mobile-control-btn" onclick="resetView()" title="Reset View">
                <i class="fas fa-sync-alt"></i>
            </button>
            <button class="mobile-control-btn secondary" onclick="fitToScreen()" title="Fit to Screen">
                <i class="fas fa-expand"></i>
            </button>
            <button class="mobile-control-btn outline" onclick="toggleLabels()" title="Toggle Labels">
                <i class="fas fa-tags"></i>
            </button>
            <button class="mobile-control-btn" onclick="expandAll()" title="Expand All">
                <i class="fas fa-expand-arrows-alt"></i>
            </button>
        </div>
    </div>

    <div class="viz-app">
        <!-- Enhanced Desktop Control Panel -->
        <div class="viz-control-panel collapsed" id="vizControlPanel">
            <div class="panel-toggle" onclick="toggleVizPanel()" role="button" tabindex="0" aria-label="Toggle Control Panel">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" aria-hidden="true">
                    <polyline points="9 18 15 12 9 6"></polyline>
                </svg>
            </div>
            
            <div class="viz-panel-header">
                <h1><i class="fas fa-sitemap" style="margin-right: 0.5rem;"></i>Site Structure</h1>
                <p>Interactive visualization and analysis of your website's structure and navigation patterns</p>
            </div>
            
            <!-- Enhanced Search Section -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-search" style="margin-right: 0.5rem;"></i>
                    Search & Filter
                </div>
                <div class="viz-search-box">
                    <input type="text" 
                           class="viz-search-input" 
                           id="desktopSearchInput" 
                           placeholder="Search nodes by name or URL..."
                           autocomplete="off"
                           aria-label="Search nodes">
                    <svg class="viz-search-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="11" cy="11" r="8"></circle>
                        <path d="m21 21-4.35-4.35"></path>
                    </svg>
                </div>
            </div>
            
            <!-- Enhanced Layout Controls -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-project-diagram" style="margin-right: 0.5rem;"></i>
                    Layout Options
                </div>
                <select id="desktopLayoutSelect" class="viz-control-select" aria-label="Layout Type">
                    <option value="radial">üåê Radial Layout</option>
                    <option value="tree">üå≥ Tree Layout</option>
                    <option value="cluster">üîó Cluster Layout</option>
                </select>
                
                <div class="viz-slider-control">
                    <div class="viz-slider-label">
                        <span><i class="fas fa-arrows-alt-h" style="margin-right: 0.25rem;"></i>Node Distance</span>
                        <span class="viz-slider-value" id="distanceValue">80</span>
                    </div>
                    <input type="range" 
                           class="viz-slider-input"
                           id="distanceSlider" 
                           min="40" 
                           max="200" 
                           value="80"
                           style="--slider-progress: 25%"
                           aria-label="Node Distance">
                </div>
                
                <div class="viz-slider-control">
                    <div class="viz-slider-label">
                        <span><i class="fas fa-expand-arrows-alt" style="margin-right: 0.25rem;"></i>Node Size</span>
                        <span class="viz-slider-value" id="sizeValue">100%</span>
                    </div>
                    <input type="range" 
                           class="viz-slider-input"
                           id="sizeSlider" 
                           min="50" 
                           max="150" 
                           value="100"
                           style="--slider-progress: 50%"
                           aria-label="Node Size">
                </div>
            </div>
            
            <!-- Enhanced View Controls -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-eye" style="margin-right: 0.5rem;"></i>
                    View Controls
                </div>
                <div class="viz-control-grid">
                    <button class="viz-control-button" onclick="resetView()" aria-label="Reset View">
                        <i class="fas fa-sync-alt"></i>
                        Reset
                    </button>
                    <button class="viz-control-button" onclick="fitToScreen()" aria-label="Fit to Screen">
                        <i class="fas fa-expand"></i>
                        Fit
                    </button>
                </div>
                
                <div class="viz-control-grid">
                    <button class="viz-control-button" onclick="expandAll()" aria-label="Expand All Nodes">
                        <i class="fas fa-plus-circle"></i>
                        Expand All
                    </button>
                    <button class="viz-control-button" onclick="collapseAll()" aria-label="Collapse All Nodes">
                        <i class="fas fa-minus-circle"></i>
                        Collapse All
                    </button>
                </div>
                
                <button class="viz-control-button" onclick="toggleLabels()" aria-label="Toggle Node Labels">
                    <i class="fas fa-tags"></i>
                    Toggle Labels
                </button>
            </div>
            
            <!-- Enhanced Grouping Options -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-layer-group" style="margin-right: 0.5rem;"></i>
                    Grouping
                </div>
                <select id="groupSelect" class="viz-control-select" aria-label="Grouping Method">
                    <option value="none">No Grouping</option>
                    <option value="domain">üìç Group by Domain</option>
                    <option value="path">üìÅ Group by Path</option>
                    <option value="status">üö¶ Group by Status</option>
                    <option value="depth">üìä Group by Depth</option>
                </select>
            </div>
            
            <!-- Enhanced Legend -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-info-circle" style="margin-right: 0.5rem;"></i>
                    Legend
                </div>
                <div class="viz-legend-grid">
                    <div class="viz-legend-group">
                        <div class="viz-legend-title">üìä Status Codes</div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: linear-gradient(45deg, #10b981, #059669);"></div>
                            <span>2xx Success</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: linear-gradient(45deg, #f59e0b, #d97706);"></div>
                            <span>3xx Redirect</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: linear-gradient(45deg, #ef4444, #dc2626);"></div>
                            <span>4xx Error</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: linear-gradient(45deg, #8b5cf6, #7c3aed);"></div>
                            <span>5xx Server</span>
                        </div>
                    </div>
                    
                    <div class="viz-legend-group">
                        <div class="viz-legend-title">üéØ Node Types</div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background: linear-gradient(45deg, var(--primary), var(--secondary));"></div>
                            <span>Domain Root</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background-color: var(--primary);"></div>
                            <span>Web Page</span>
                        </div>
                        <div class="viz-legend-item">
                            <div class="viz-legend-color" style="background-color: var(--accent);"></div>
                            <span>Resource</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Enhanced Export Options -->
            <div class="viz-control-section">
                <div class="viz-section-title">
                    <i class="fas fa-download" style="margin-right: 0.5rem;"></i>
                    Export & Actions
                </div>
                <a href="{{ url_for('download_results') }}" class="viz-control-button primary" aria-label="Download Results">
                    <i class="fas fa-download"></i>
                    Download Results
                </a>
            </div>
        </div>
        
        <!-- Main Visualization Container -->
        <div class="viz-container">
            <svg id="visualization" role="img" aria-label="Site structure visualization"></svg>
            
            <!-- Enhanced Node Info Panel -->
            <div class="viz-node-info" id="vizNodeInfo" role="dialog" aria-labelledby="vizNodeTitle">
                <div class="viz-node-info-header">
                    <h3 class="viz-node-info-title" id="vizNodeTitle">Node Information</h3>
                    <button class="viz-node-info-close" onclick="closeVizNodeInfo()" aria-label="Close node information">
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <line x1="18" y1="6" x2="6" y2="18"></line>
                            <line x1="6" y1="6" x2="18" y2="18"></line>
                        </svg>
                    </button>
                </div>
                <div id="vizNodeInfoContent"></div>
            </div>
            
            <!-- Enhanced Zoom Controls -->
            <div class="viz-zoom-controls">
                <button class="viz-zoom-button" onclick="zoomIn()" aria-label="Zoom In" title="Zoom In">
                    <i class="fas fa-plus"></i>
                </button>
                <button class="viz-zoom-button" onclick="zoomOut()" aria-label="Zoom Out" title="Zoom Out">
                    <i class="fas fa-minus"></i>
                </button>
                <button class="viz-zoom-button" onclick="resetView()" aria-label="Reset Zoom" title="Reset View">
                    <i class="fas fa-home"></i>
                </button>
            </div>
            
            <!-- Enhanced Loading Overlay -->
            <div class="viz-loading-overlay" id="vizLoadingOverlay">
                <div class="viz-loading-spinner"></div>
                <div class="viz-loading-text">Loading visualization...</div>
            </div>
        </div>
    </div>
</div>

<div class="viz-tooltip" id="vizTooltip" role="tooltip"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script>
// Enhanced Site Visualization Class - CORRECTED VERSION
class SiteVisualization {
    constructor() {
        this.svg = null;
        this.g = null;
        this.zoom = null;
        this.root = null;
        this.simulation = null;
        this.nodes = null;
        this.links = null;
        this.labels = null;
        
        // State management - FIXED INITIAL STATE
        this.state = {
            showLabels: false,  // Start with labels visible
            currentLayout: "radial",
            currentGrouping: "none",
            nodeDistance: 80,
            nodeScale: 1.0,
            selectedNode: null,
            searchTerm: "",
            isLoading: false
        };
        
        // Mobile detection
        this.isMobile = window.innerWidth <= 768;
        this.isTouch = 'ontouchstart' in window;
        
        // Dimensions
        this.width = 0;
        this.height = 0;
        
        // Enhanced color scheme
        this.colors = {
            primary: getComputedStyle(document.documentElement).getPropertyValue('--primary').trim(),
            secondary: getComputedStyle(document.documentElement).getPropertyValue('--secondary').trim(),
            accent: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim(),
            text: getComputedStyle(document.documentElement).getPropertyValue('--text').trim(),
            textLight: getComputedStyle(document.documentElement).getPropertyValue('--text-light').trim(),
            surface: getComputedStyle(document.documentElement).getPropertyValue('--surface').trim(),
            background: getComputedStyle(document.documentElement).getPropertyValue('--background').trim()
        };
        
        this.statusColors = {
            success: "#10b981",
            redirect: "#f59e0b", 
            client_error: "#ef4444",
            server_error: "#8b5cf6",
            unknown: "#64748b"
        };
        
        // Debounce function
        this.debounce = (func, wait) => {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        };
        
        this.init();
    }
    
    init() {
        this.setupDimensions();
        this.setupSVG();
        this.setupEventListeners();
        this.loadData();
        
        // FIXED: Apply initial state properly
        this.applySavedState();
    }
    
    setupDimensions() {
        const container = document.querySelector('.viz-container');
        this.width = container.clientWidth;
        this.height = container.clientHeight;
    }
    
    setupSVG() {
        this.svg = d3.select("#visualization")
            .attr("width", this.width)
            .attr("height", this.height);
            
        // Enhanced zoom with better mobile support
        this.zoom = d3.zoom()
            .scaleExtent([0.1, 10])
            .filter((event) => {
                if (this.isTouch) {
                    return event.type !== 'mousedown' || event.touches?.length === 2;
                }
                return true;
            })
            .on("zoom", (event) => {
                this.g.attr("transform", event.transform);
                this.saveState();
            });
            
        this.svg.call(this.zoom);
        
        // Enhanced definitions with gradients and filters
        this.setupSVGDefinitions();
        
        // Main group
        this.g = this.svg.append("g");
        
        // Layered groups for better rendering order
        this.linkGroup = this.g.append("g").attr("class", "links");
        this.nodeGroup = this.g.append("g").attr("class", "nodes");
        this.labelGroup = this.g.append("g").attr("class", "labels");
    }
    
    setupSVGDefinitions() {
        const defs = this.svg.append("defs");
        
        // Enhanced gradient for domain nodes
        const domainGradient = defs.append("linearGradient")
            .attr("id", "domainGradient")
            .attr("x1", "0%")
            .attr("y1", "0%")
            .attr("x2", "100%")
            .attr("y2", "100%");
            
        domainGradient.append("stop")
            .attr("offset", "0%")
            .attr("stop-color", this.colors.primary);
            
        domainGradient.append("stop")
            .attr("offset", "100%")
            .attr("stop-color", this.colors.secondary);
        
        // Enhanced drop shadow filter
        const shadowFilter = defs.append("filter")
            .attr("id", "drop-shadow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");
            
        shadowFilter.append("feGaussianBlur")
            .attr("in", "SourceAlpha")
            .attr("stdDeviation", 4);
            
        shadowFilter.append("feOffset")
            .attr("dx", 0)
            .attr("dy", 2);
            
        shadowFilter.append("feComponentTransfer")
            .append("feFuncA")
            .attr("type", "linear")
            .attr("slope", 0.3);
            
        const feMerge = shadowFilter.append("feMerge");
        feMerge.append("feMergeNode");
        feMerge.append("feMergeNode")
            .attr("in", "SourceGraphic");
        
        // Glow filter for highlighted nodes
        const glowFilter = defs.append("filter")
            .attr("id", "glow")
            .attr("x", "-50%")
            .attr("y", "-50%")
            .attr("width", "200%")
            .attr("height", "200%");
            
        glowFilter.append("feGaussianBlur")
            .attr("stdDeviation", 3)
            .attr("result", "coloredBlur");
            
        const glowMerge = glowFilter.append("feMerge");
        glowMerge.append("feMergeNode")
            .attr("in", "coloredBlur");
        glowMerge.append("feMergeNode")
            .attr("in", "SourceGraphic");
    }
    
    setupEventListeners() {
        // Search handlers for both mobile and desktop
        this.setupSearchHandler('mobileSearchInput');
        this.setupSearchHandler('desktopSearchInput');
        
        // Layout selector synchronization
        this.syncLayoutSelectors();
        
        // Slider handlers
        this.setupSliderHandlers();
        
        // Grouping handler
        document.getElementById('groupSelect')?.addEventListener('change', (e) => {
            this.state.currentGrouping = e.target.value;
            this.updateVisualization();
            this.saveState();
        });
        
        // Enhanced window resize handler with debouncing
        const handleResize = this.debounce(() => {
            this.setupDimensions();
            this.svg.attr("width", this.width).attr("height", this.height);
            this.updateVisualization();
        }, 250);
        
        window.addEventListener('resize', handleResize);
        
        // Orientation change for mobile
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                this.setupDimensions();
                this.svg.attr("width", this.width).attr("height", this.height);
                this.updateVisualization();
            }, 100);
        });
        
        // Auto-save state
        window.addEventListener('beforeunload', () => {
            this.saveState();
        });
    }
    
    syncLayoutSelectors() {
        const mobileSelect = document.getElementById('mobileLayoutSelect');
        const desktopSelect = document.getElementById('desktopLayoutSelect');
        
        const handleLayoutChange = (value, sourceElement) => {
            this.state.currentLayout = value;
            
            // Sync the other selector
            if (sourceElement === mobileSelect && desktopSelect) {
                desktopSelect.value = value;
            } else if (sourceElement === desktopSelect && mobileSelect) {
                mobileSelect.value = value;
            }
            
            this.updateVisualization();
            this.saveState();
        };
        
        mobileSelect?.addEventListener('change', (e) => {
            handleLayoutChange(e.target.value, mobileSelect);
        });
        
        desktopSelect?.addEventListener('change', (e) => {
            handleLayoutChange(e.target.value, desktopSelect);
        });
    }
    
    setupSliderHandlers() {
        // Desktop sliders
        const distanceSlider = document.getElementById('distanceSlider');
        const sizeSlider = document.getElementById('sizeSlider');
        
        // Mobile sliders
        const mobileDistanceSlider = document.getElementById('mobileDistanceSlider');
        const mobileSizeSlider = document.getElementById('mobileSizeSlider');
        
        const handleDistanceChange = (value) => {
            this.state.nodeDistance = parseInt(value);
            this.updateSliderDisplay('distance', value);
            if (this.state.currentLayout === 'force') {
                this.updateForceSimulation();
            }
            this.saveState();
        };
        
        const handleSizeChange = (value) => {
            this.state.nodeScale = parseInt(value) / 100;
            this.updateSliderDisplay('size', value);
            this.updateNodeSizes();
            this.saveState();
        };
        
        // Sync desktop sliders
        distanceSlider?.addEventListener('input', (e) => {
            handleDistanceChange(e.target.value);
            if (mobileDistanceSlider) mobileDistanceSlider.value = e.target.value;
        });
        
        sizeSlider?.addEventListener('input', (e) => {
            handleSizeChange(e.target.value);
            if (mobileSizeSlider) mobileSizeSlider.value = e.target.value;
        });
        
        // Sync mobile sliders
        mobileDistanceSlider?.addEventListener('input', (e) => {
            handleDistanceChange(e.target.value);
            if (distanceSlider) distanceSlider.value = e.target.value;
        });
        
        mobileSizeSlider?.addEventListener('input', (e) => {
            handleSizeChange(e.target.value);
            if (sizeSlider) sizeSlider.value = e.target.value;
        });
    }
    
    updateSliderDisplay(type, value) {
        if (type === 'distance') {
            document.getElementById('distanceValue').textContent = value;
            document.getElementById('mobileDistanceValue').textContent = value;
            
            const percentage = ((value - 40) / (200 - 40)) * 100;
            document.getElementById('distanceSlider')?.style.setProperty('--slider-progress', `${percentage}%`);
        } else if (type === 'size') {
            const displayValue = value + '%';
            document.getElementById('sizeValue').textContent = displayValue;
            document.getElementById('mobileSizeValue').textContent = displayValue;
            
            const percentage = ((value - 50) / (150 - 50)) * 100;
            document.getElementById('sizeSlider')?.style.setProperty('--slider-progress', `${percentage}%`);
        }
    }
    
    setupSearchHandler(inputId) {
        const searchInput = document.getElementById(inputId);
        if (!searchInput) return;
        
        const debouncedSearch = this.debounce((value) => {
            this.state.searchTerm = value;
            this.handleSearch(value);
            this.saveState();
        }, 300);
        
        searchInput.addEventListener('input', (e) => {
            debouncedSearch(e.target.value);
        });
        
        // Sync search inputs
        searchInput.addEventListener('input', (e) => {
            const otherInputId = inputId === 'mobileSearchInput' ? 'desktopSearchInput' : 'mobileSearchInput';
            const otherInput = document.getElementById(otherInputId);
            if (otherInput && otherInput.value !== e.target.value) {
                otherInput.value = e.target.value;
            }
        });
    }
    
    async loadData() {
        this.showLoading(true);
        console.log('üîÑ Starting data load...');
        
        try {
            console.log('üì° Fetching data from /data endpoint...');
            const response = await fetch('/data', {
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json',
                    'X-Requested-With': 'XMLHttpRequest'
                },
                credentials: 'same-origin'
            });
            
            console.log(`üìä Response status: ${response.status}`);
            
            if (response.status === 202) {
                const data = await response.json();
                console.log('‚è≥ Crawl still in progress, redirecting...');
                window.location.href = '/loading';
                return;
            }
            
            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                console.error('‚ùå Response not OK:', response.status, errorData);
                throw new Error(errorData.message || `HTTP ${response.status}: ${response.statusText}`);
            }
            
            const data = await response.json();
            console.log('‚úÖ Data received:', data);
            
            if (data.error) {
                console.error('‚ùå Data contains error:', data.error);
                throw new Error(data.error);
            }
            
            // Validate data structure
            if (!this.validateDataStructure(data)) {
                throw new Error('Invalid data structure received from server');
            }
            
            console.log('üé® Processing data for visualization...');
            const treeData = this.transformData(data.home_links, data.status_codes);
            this.processData(treeData);
            
            console.log('‚úÖ Data loaded successfully');
            
        } catch (error) {
            console.error('‚ùå Error loading data:', error);
            this.showMessage('error', `Failed to load crawl data: ${error.message}`, 'Please try starting a new crawl');
        } finally {
            this.showLoading(false);
        }
    }
    
    validateDataStructure(data) {
        if (!data || typeof data !== 'object') {
            console.error('‚ùå Data is not an object');
            return false;
        }
        
        if (!data.home_links || typeof data.home_links !== 'object') {
            console.error('‚ùå Missing or invalid home_links');
            return false;
        }
        
        const homeLinksCount = Object.keys(data.home_links).length;
        const statusCodesCount = Object.keys(data.status_codes || {}).length;
        
        console.log(`üìà Data validation: ${homeLinksCount} home links, ${statusCodesCount} status codes`);
        
        if (homeLinksCount === 0) {
            console.warn('‚ö†Ô∏è No home links data found');
            return false;
        }
        
        return true;
    }

    showMessage(type, title, subtitle = '') {
        const overlay = document.getElementById('vizLoadingOverlay');
        const spinner = overlay.querySelector('.viz-loading-spinner');
        const text = overlay.querySelector('.viz-loading-text');
        
        if (spinner) spinner.style.display = 'none';
        
        if (text) {
            const icon = type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            text.innerHTML = `
                <div style="text-align: center;">
                    <div style="font-size: 2rem; margin-bottom: 1rem;">${icon}</div>
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">${title}</div>
                    ${subtitle ? `<div style="color: var(--text-light); font-size: 0.875rem;">${subtitle}</div>` : ''}
                    <div style="margin-top: 1.5rem;">
                        <a href="/site_structure" class="viz-control-button primary" style="text-decoration: none;">
                            Start New Crawl
                        </a>
                    </div>
                </div>
            `;
        }
        
        overlay.classList.remove('hidden');
    }
    
    createSampleData() {
        return {
            name: "Site Root",
            url: "/",
            status: "200",
            type: "domain",
            children: [
                {
                    name: "Home Page",
                    url: "/",
                    status: "200",
                    type: "page",
                    children: [
                        { name: "About", url: "/about", status: "200", type: "page", children: [] },
                        { name: "Contact", url: "/contact", status: "200", type: "page", children: [] },
                        { name: "Services", url: "/services", status: "200", type: "page", children: [] },
                        { name: "Blog", url: "/blog", status: "200", type: "page", children: [
                            { name: "Post 1", url: "/blog/post-1", status: "200", type: "page", children: [] },
                            { name: "Post 2", url: "/blog/post-2", status: "404", type: "page", children: [] }
                        ]}
                    ]
                }
            ]
        };
    }
    
    transformData(links, statusCodes) {
        const root = { 
            name: "Site Root", 
            url: "/",
            status: "200",
            type: "domain",
            children: [] 
        };
        
        for (let domain in links) {
            const domainNode = this.transformNode(links[domain], statusCodes);
            domainNode.type = "domain";
            root.children.push(domainNode);
        }
        
        return root;
    }
    
    transformNode(nodeData, statusCodes) {
        const node = {
            name: nodeData.name || "Unknown",
            url: nodeData.url || "#",
            status: nodeData.status || (statusCodes && statusCodes[nodeData.url]) || "Unknown",
            type: this.getNodeType(nodeData.url),
            children: []
        };
        
        if (nodeData.children) {
            for (let childKey in nodeData.children) {
                const childNode = this.transformNode(nodeData.children[childKey], statusCodes);
                node.children.push(childNode);
            }
        }
        
        return node;
    }
    
    getNodeType(url) {
        if (!url || url === "#") return "page";
        if (url.match(/\.(jpg|jpeg|png|gif|svg|webp|ico)$/i)) return "image";
        if (url.match(/\.(css|scss|sass|less)$/i)) return "style";
        if (url.match(/\.(js|ts|jsx|tsx)$/i)) return "script";
        if (url.match(/\.(pdf|doc|docx|xls|xlsx)$/i)) return "document";
        return "page";
    }
    
    processData(data) {
        this.root = d3.hierarchy(data);
        
        // Enhanced node processing with better metadata
        this.root.descendants().forEach((d, i) => {
            d.index = i;
            d.id = `node-${i}`;
            
            if (d.data.url && d.data.url !== "#") {
                try {
                    const url = new URL(d.data.url, 'https://example.com');
                    d.data.domain = url.hostname;
                    d.data.path = url.pathname;
                    d.data.pathSegments = url.pathname.split('/').filter(s => s);
                } catch (e) {
                    d.data.domain = "unknown";
                    d.data.path = "/";
                    d.data.pathSegments = [];
                }
            }
            
            d.data.childCount = d.children ? d.children.length : 0;
            d.data.totalDescendants = d.descendants().length - 1;
        });
        
        this.updateVisualization();
    }
    
    // FIXED: Complete visualization update with proper cleanup
    updateVisualization() {
        console.log(`üé® Updating visualization with layout: ${this.state.currentLayout}`);
        
        // Clear existing elements
        this.linkGroup.selectAll("*").remove();
        this.nodeGroup.selectAll("*").remove();
        this.labelGroup.selectAll("*").remove();
        
        // CRITICAL FIX: Stop and clean up existing simulation
        if (this.simulation) {
            this.simulation.stop();
            this.simulation = null;
        }
        
        // CRITICAL FIX: Clear all fixed positions from nodes
        this.clearNodePositions();
        
        // Apply selected layout
        this.applyLayout();
        
        // Draw visualization elements
        this.drawLinks();
        this.drawNodes();
        
        // FIXED: Proper label initialization
        if (this.state.showLabels) {
            this.drawLabels();
        }
        
        // Apply search filtering if active
        if (this.state.searchTerm) {
            this.handleSearch(this.state.searchTerm);
        }
        
        console.log(`‚úÖ Visualization updated with layout: ${this.state.currentLayout}`);
    }
    
    // CRITICAL FIX: Clear all node positions to allow proper layout switching
    clearNodePositions() {
        if (this.root) {
            this.root.descendants().forEach(d => {
                // Clear fixed positions
                d.fx = null;
                d.fy = null;
                // Clear velocity
                d.vx = null;
                d.vy = null;
                // Reset positions to center for force layout
                if (this.state.currentLayout === 'force') {
                    d.x = this.width / 2 + (Math.random() - 0.5) * 100;
                    d.y = this.height / 2 + (Math.random() - 0.5) * 100;
                }
            });
        }
    }
    
    applyLayout() {
        switch (this.state.currentLayout) {
            case 'radial':
                this.applyRadialLayout();
                break;
            case 'force':
                this.applyForceLayout();
                break;
            case 'tree':
                this.applyTreeLayout();
                break;
            case 'cluster':
                this.applyClusterLayout();
                break;
        }
    }
    
    applyRadialLayout() {
        console.log('üåê Applying radial layout');
        
        const radius = Math.min(this.width, this.height) / 3;
        
        const treeLayout = d3.tree()
            .size([2 * Math.PI, radius])
            .separation((a, b) => (a.parent === b.parent ? 1 : 2) / a.depth);
            
        treeLayout(this.root);
        
        // Convert to Cartesian coordinates with center offset
        this.root.descendants().forEach(d => {
            const angle = d.x - Math.PI / 2;
            const r = d.y;
            d.x = r * Math.cos(angle) + this.width / 2;
            d.y = r * Math.sin(angle) + this.height / 2;
        });
    }
    
    // FIXED: Complete force layout implementation
    applyForceLayout() {
        console.log('‚ö° Applying force-directed layout');
        
        const nodes = this.root.descendants();
        const links = this.root.links();
        
        // CRITICAL: Create new simulation
        this.simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links)
                .id(d => d.id)
                .distance(this.state.nodeDistance)
                .strength(0.8))
            .force("charge", d3.forceManyBody()
                .strength(-400)
                .distanceMax(300))
            .force("center", d3.forceCenter(this.width / 2, this.height / 2))
            .force("collide", d3.forceCollide()
                .radius(d => this.getNodeSize(d) * this.state.nodeScale + 15)
                .strength(0.7))
            .alpha(1)  // Start with high alpha for visible animation
            .alphaDecay(0.02)  // Slower decay for longer animation
            .on("tick", () => {
                this.updatePositions();
            })
            .on("end", () => {
                console.log('‚úÖ Force simulation completed');
            });
        
        console.log(`‚ö° Force simulation started with ${nodes.length} nodes and ${links.length} links`);
    }
    
    applyTreeLayout() {
        console.log('üå≥ Applying tree layout');
        
        const treeLayout = d3.tree()
            .nodeSize([this.state.nodeDistance * 1.5, this.state.nodeDistance * 2]);
            
        treeLayout(this.root);
        this.centerTree();
    }
    
    applyClusterLayout() {
        console.log('üîó Applying cluster layout');
        
        const clusterLayout = d3.cluster()
            .nodeSize([this.state.nodeDistance * 1.5, this.state.nodeDistance * 2]);
            
        clusterLayout(this.root);
        this.centerTree();
    }
    
    centerTree() {
        const bounds = this.getTreeBounds();
        const dx = this.width / 2 - bounds.x - bounds.width / 2;
        const dy = this.height / 2 - bounds.y - bounds.height / 2;
        
        this.root.descendants().forEach(d => {
            d.x += dx;
            d.y += dy;
        });
    }
    
    getTreeBounds() {
        let minX = Infinity, maxX = -Infinity;
        let minY = Infinity, maxY = -Infinity;
        
        this.root.descendants().forEach(d => {
            minX = Math.min(minX, d.x);
            maxX = Math.max(maxX, d.x);
            minY = Math.min(minY, d.y);
            maxY = Math.max(maxY, d.y);
        });
        
        return {
            x: minX,
            y: minY,
            width: maxX - minX,
            height: maxY - minY
        };
    }
    
    drawLinks() {
        const linkGenerator = d3.linkHorizontal()
            .x(d => d.x)
            .y(d => d.y);
            
        this.links = this.linkGroup.selectAll(".link")
            .data(this.root.links())
            .join("path")
            .attr("class", "link")
            .attr("d", linkGenerator)
            .style("stroke-dasharray", d => {
                if (d.target.data.type === 'resource') return "5,5";
                return "none";
            });
    }
    
    drawNodes() {
        const nodeGroups = this.nodeGroup.selectAll(".node")
            .data(this.root.descendants())
            .join("g")
            .attr("class", "node")
            .attr("transform", d => `translate(${d.x},${d.y})`)
            .style("cursor", "pointer")
            .on("click", (event, d) => this.handleNodeClick(event, d))
            .call(this.createDragBehavior());
        
        // Enhanced mobile/touch handling
        if (this.isTouch) {
            nodeGroups
                .on("touchstart", (event, d) => {
                    event.preventDefault();
                    this.handleNodeTouch(event, d);
                });
        } else {
            nodeGroups
                .on("mouseover", (event, d) => this.handleNodeHover(event, d))
                .on("mouseout", () => this.handleNodeOut());
        }
        
        // Enhanced background circle for better touch targets
        nodeGroups.append("circle")
            .attr("class", "node-background")
            .attr("r", d => this.getNodeSize(d) * this.state.nodeScale + (this.isMobile ? 15 : 10))
            .style("fill", "transparent")
            .style("stroke", "none");
        
        // Main node circle
        nodeGroups.append("circle")
            .attr("class", "node-circle")
            .attr("r", d => this.getNodeSize(d) * this.state.nodeScale)
            .style("fill", d => this.getNodeColor(d))
            .style("stroke", d => this.getNodeStrokeColor(d))
            .style("filter", "url(#drop-shadow)")
            .style("transition", "all 0.3s ease");
        
        // Enhanced icons for different node types
        nodeGroups.filter(d => d.data.type !== "page" && d.data.type !== "domain")
            .append("text")
            .attr("class", "node-icon")
            .attr("dy", "0.35em")
            .attr("text-anchor", "middle")
            .style("fill", "white")
            .style("font-size", d => `${this.getNodeSize(d) * this.state.nodeScale * 0.6}px`)
            .style("font-weight", "600")
            .style("pointer-events", "none")
            .text(d => this.getNodeIcon(d));
        
        this.nodes = nodeGroups;
    }
    
    // FIXED: Proper label drawing with correct visibility
    drawLabels() {
        console.log(`üè∑Ô∏è Drawing labels (showLabels: ${this.state.showLabels})`);
        
        // Clear existing labels first
        this.labelGroup.selectAll(".label").remove();
        
        if (!this.state.showLabels) {
            this.labels = null;
            return;
        }
        
        this.labels = this.labelGroup.selectAll(".label")
            .data(this.root.descendants())
            .join("text")
            .attr("class", "label")
            .attr("x", d => d.x)
            .attr("y", d => d.y + this.getNodeSize(d) * this.state.nodeScale + 20)
            .attr("text-anchor", "middle")
            .style("font-size", d => `${(this.isMobile ? 12 : 11) * this.state.nodeScale}px`)
            .style("font-weight", "500")
            .style("fill", this.colors.text)
            .style("text-shadow", "0 1px 3px rgba(255, 255, 255, 0.8)")
            .style("pointer-events", "none")
            .style("opacity", 1)  // Ensure labels are visible
            .text(d => this.truncateText(d.data.name, this.isMobile ? 12 : 18));
            
        console.log(`‚úÖ Labels drawn: ${this.labels.size()} labels created`);
    }
    
    getNodeSize(node) {
        const baseSize = this.isMobile ? 
            Math.max(20 - node.depth * 3, 10) : 
            Math.max(16 - node.depth * 2, 8);
        
        const childBonus = Math.sqrt(node.data.childCount) * 2;
        
        return baseSize + childBonus;
    }
    
    getNodeColor(node) {
        const status = parseInt(node.data.status);
        
        if (!isNaN(status)) {
            if (status >= 200 && status < 300) return this.statusColors.success;
            if (status >= 300 && status < 400) return this.statusColors.redirect;
            if (status >= 400 && status < 500) return this.statusColors.client_error;
            if (status >= 500) return this.statusColors.server_error;
        }
        
        if (node.depth === 0 || node.data.type === 'domain') {
            return "url(#domainGradient)";
        }
        
        if (node.data.type === 'resource') {
            return this.colors.accent;
        }
        
        return this.colors.primary;
    }
    
    getNodeIcon(node) {
        const icons = {
            'image': 'üñº',
            'style': 'üé®',
            'script': '‚öô',
            'document': 'üìÑ'
        };
        return icons[node.data.type] || 'üìÑ';
    }
    
    truncateText(text, maxLength) {
        if (text.length > maxLength) {
            return text.substring(0, maxLength) + "‚Ä¶";
        }
        return text;
    }
    
    handleSearch(searchTerm) {
        const term = searchTerm.toLowerCase().trim();
        
        if (!term) {
            this.nodes?.classed("highlighted", false);
            this.nodes?.style("opacity", 1);
            this.links?.style("opacity", 1);
            this.labels?.style("opacity", 1);
            return;
        }
        
        const matches = this.root.descendants().filter(d => 
            d.data.name.toLowerCase().includes(term) ||
            (d.data.url && d.data.url.toLowerCase().includes(term)) ||
            (d.data.domain && d.data.domain.toLowerCase().includes(term))
        );
        
        this.nodes?.style("opacity", 0.2);
        this.links?.style("opacity", 0.1);
        this.labels?.style("opacity", 0.2);
        
        matches.forEach(node => {
            let current = node;
            while (current) {
                d3.select(this.nodes?.nodes()[current.index])
                    .style("opacity", 1)
                    .classed("highlighted", true);
                    
                d3.select(this.labels?.nodes()[current.index])
                    .style("opacity", 1);
                
                if (current.parent) {
                    const link = this.root.links().find(l => 
                        l.source === current.parent && l.target === current
                    );
                    if (link) {
                        const linkIndex = this.root.links().indexOf(link);
                        d3.select(this.links?.nodes()[linkIndex])
                            .style("opacity", 0.8)
                            .classed("highlighted", true);
                    }
                }
                
                current = current.parent;
            }
        });
        
        if (matches.length > 0) {
            this.focusNode(matches[0]);
        }
    }
    
    handleNodeClick(event, node) {
        event.stopPropagation();
        
        if (this.state.selectedNode === node) {
            if (node.children || node._children) {
                if (node.children) {
                    node._children = node.children;
                    node.children = null;
                } else {
                    node.children = node._children;
                    node._children = null;
                }
                this.updateVisualization();
            }
        } else {
            this.selectNode(node);
        }
    }
    
    handleNodeTouch(event, node) {
        this.selectNode(node);
        
        const nodeElement = event.currentTarget;
        const circle = nodeElement.querySelector('.node-circle');
        
        if (circle) {
            circle.style.transform = 'scale(1.2)';
            circle.style.filter = 'url(#glow)';
            
            setTimeout(() => {
                circle.style.transform = '';
                circle.style.filter = 'url(#drop-shadow)';
            }, 200);
        }
    }
    
    selectNode(node) {
        this.state.selectedNode = node;
        this.nodes?.classed("selected", d => d === node);
        this.showNodeInfo(node);
        this.saveState();
    }
    
    showNodeInfo(node) {
        const panel = document.getElementById('vizNodeInfo');
        const title = document.getElementById('vizNodeTitle');
        const content = document.getElementById('vizNodeInfoContent');
        
        title.textContent = node.data.name;
        
        const info = [
            {
                label: 'URL',
                value: `<a href="${node.data.url}" target="_blank" rel="noopener noreferrer">${this.formatURL(node.data.url)}</a>`
            },
            { label: 'Status', value: this.getStatusBadge(node.data.status) },
            { label: 'Type', value: this.formatNodeType(node.data.type) },
            { label: 'Depth', value: node.depth },
            { label: 'Children', value: node.data.childCount },
            { label: 'Total Descendants', value: node.data.totalDescendants },
            { label: 'Domain', value: node.data.domain || 'N/A' },
            { label: 'Path', value: node.data.path || 'N/A' }
        ];

        content.innerHTML = info.map(item => `
            <div class="viz-node-info-row">
                <span class="viz-node-info-label">${item.label}</span>
                <span class="viz-node-info-value">${item.value}</span>
            </div>
        `).join('');
        
        panel.classList.add('visible');
        panel.setAttribute('aria-hidden', 'false');
    }
    
    formatURL(url) {
        if (!url || url === '#') return 'N/A';
        if (url.length > 40) {
            return url.substring(0, 37) + '...';
        }
        return url;
    }
    
    formatNodeType(type) {
        const typeLabels = {
            'domain': 'üåê Domain',
            'page': 'üìÑ Page',
            'image': 'üñº Image',
            'style': 'üé® Stylesheet',
            'script': '‚öô Script',
            'document': 'üìÑ Document'
        };
        return typeLabels[type] || `üìÑ ${type}`;
    }
    
    getStatusBadge(status) {
        const code = parseInt(status);
        let type = 'unknown';
        let icon = '‚ùì';
        
        if (!isNaN(code)) {
            if (code >= 200 && code < 300) { type = 'success'; icon = '‚úÖ'; }
            else if (code >= 300 && code < 400) { type = 'warning'; icon = 'üîÑ'; }
            else if (code >= 400 && code < 500) { type = 'danger'; icon = '‚ùå'; }
            else if (code >= 500) { type = 'danger'; icon = '‚ö†Ô∏è'; }
        }
        
        return `<span class="viz-status-badge viz-status-${type}">${icon} ${status}</span>`;
    }
    
    closeNodeInfo() {
        const panel = document.getElementById('vizNodeInfo');
        panel.classList.remove('visible');
        panel.setAttribute('aria-hidden', 'true');
        this.state.selectedNode = null;
        this.nodes?.classed("selected", false);
        this.saveState();
    }
    
    handleNodeHover(event, node) {
        if (this.isMobile) return;
        
        const tooltip = document.getElementById('vizTooltip');
        
        tooltip.innerHTML = `
            <div style="font-weight: 600; margin-bottom: 0.5rem;">${node.data.name}</div>
            <div><strong>Status:</strong> ${node.data.status}</div>
            <div><strong>Type:</strong> ${this.formatNodeType(node.data.type)}</div>
            <div><strong>Children:</strong> ${node.data.childCount}</div>
        `;
        
        tooltip.classList.add('visible');
        
        const rect = this.svg.node().getBoundingClientRect();
        const x = event.pageX + 15;
        const y = event.pageY - 10;
        
        const tooltipRect = tooltip.getBoundingClientRect();
        const maxX = window.innerWidth - tooltipRect.width - 10;
        const maxY = window.innerHeight - tooltipRect.height - 10;
        
        tooltip.style.left = `${Math.min(x, maxX)}px`;
        tooltip.style.top = `${Math.min(y, maxY)}px`;
    }
    
    handleNodeOut() {
        if (this.isMobile) return;
        
        const tooltip = document.getElementById('vizTooltip');
        tooltip.classList.remove('visible');
    }
    
    focusNode(node, scale = null) {
        if (!scale) {
            scale = this.isMobile ? 1.5 : 2;
        }
        
        const x = -node.x * scale + this.width / 2;
        const y = -node.y * scale + this.height / 2;
        
        this.svg.transition()
            .duration(750)
            .ease(d3.easeCubicInOut)
            .call(
                this.zoom.transform,
                d3.zoomIdentity
                    .translate(x, y)
                    .scale(scale)
            );
    }
    
    createDragBehavior() {
        return d3.drag()
            .on("start", (event, d) => this.dragStarted(event, d))
            .on("drag", (event, d) => this.dragged(event, d))
            .on("end", (event, d) => this.dragEnded(event, d));
    }
    
    dragStarted(event, d) {
        if (this.state.currentLayout === 'force' && !event.active && this.simulation) {
            this.simulation.alphaTarget(0.3).restart();
        }
        d.fx = d.x;
        d.fy = d.y;
    }
    
    dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }
    
    dragEnded(event, d) {
        if (this.state.currentLayout === 'force' && !event.active && this.simulation) {
            this.simulation.alphaTarget(0);
        }
        if (this.state.currentLayout !== 'force') {
            d.fx = null;
            d.fy = null;
        }
    }
    
    // CRITICAL FIX: Enhanced position updates for all layouts
    updatePositions() {
        if (this.links) {
            this.links.attr("d", d3.linkHorizontal()
                .x(d => d.x)
                .y(d => d.y));
        }
        
        if (this.nodes) {
            this.nodes.attr("transform", d => `translate(${d.x},${d.y})`);
        }
        
        if (this.labels && this.state.showLabels) {
            this.labels
                .attr("x", d => d.x)
                .attr("y", d => d.y + this.getNodeSize(d) * this.state.nodeScale + 20);
        }
    }
    
    updateNodeSizes() {
        if (this.nodes) {
            this.nodes.selectAll(".node-circle")
                .transition()
                .duration(300)
                .attr("r", d => this.getNodeSize(d) * this.state.nodeScale);
                
            this.nodes.selectAll(".node-background")
                .transition()
                .duration(300)
                .attr("r", d => this.getNodeSize(d) * this.state.nodeScale + (this.isMobile ? 15 : 10));
                
            this.nodes.selectAll(".node-icon")
                .transition()
                .duration(300)
                .style("font-size", d => `${this.getNodeSize(d) * this.state.nodeScale * 0.6}px`);
        }
        
        if (this.labels && this.state.showLabels) {
            this.labels
                .transition()
                .duration(300)
                .style("font-size", d => `${(this.isMobile ? 12 : 11) * this.state.nodeScale}px`)
                .attr("y", d => d.y + this.getNodeSize(d) * this.state.nodeScale + 20);
        }
    }
    
    updateForceSimulation() {
        if (this.simulation) {
            this.simulation
                .force("link")
                .distance(this.state.nodeDistance);
                
            this.simulation
                .force("collide")
                .radius(d => this.getNodeSize(d) * this.state.nodeScale + 15);
                
            this.simulation.alpha(0.3).restart();
        }
    }
    
    // State management
    saveState() {
        const state = {
            ...this.state,
            transform: d3.zoomTransform(this.svg.node())
        };
        
        localStorage.setItem('siteVizState', JSON.stringify(state));
    }
    
    // FIXED: Proper state application on load
    applySavedState() {
        try {
            const savedState = localStorage.getItem('siteVizState');
            if (savedState) {
                const state = JSON.parse(savedState);
                
                // Apply saved state carefully
                this.state = { ...this.state, ...state };
                
                // Update UI elements to match state
                this.syncStateToUI();
                
                // Apply saved transform
                if (state.transform) {
                    this.svg.call(
                        this.zoom.transform,
                        d3.zoomIdentity
                            .translate(state.transform.x, state.transform.y)
                            .scale(state.transform.k)
                    );
                }
            }
        } catch (error) {
            console.warn('Failed to load saved state:', error);
        }
    }
    
    // FIXED: Complete UI synchronization
    syncStateToUI() {
        console.log(`üîÑ Syncing state to UI - showLabels: ${this.state.showLabels}`);
        
        // Sync layout selectors
        const mobileSelect = document.getElementById('mobileLayoutSelect');
        const desktopSelect = document.getElementById('desktopLayoutSelect');
        
        if (mobileSelect) mobileSelect.value = this.state.currentLayout;
        if (desktopSelect) desktopSelect.value = this.state.currentLayout;
        
        // Sync sliders
        const elements = [
            'distanceSlider', 'sizeSlider', 
            'mobileDistanceSlider', 'mobileSizeSlider'
        ];
        
        elements.forEach(id => {
            const element = document.getElementById(id);
            if (element) {
                if (id.includes('distance')) {
                    element.value = this.state.nodeDistance;
                } else if (id.includes('size')) {
                    element.value = this.state.nodeScale * 100;
                }
            }
        });
        
        // Update displays
        this.updateSliderDisplay('distance', this.state.nodeDistance);
        this.updateSliderDisplay('size', this.state.nodeScale * 100);
        
        // Sync search inputs
        const searchInputs = ['mobileSearchInput', 'desktopSearchInput'];
        searchInputs.forEach(id => {
            const input = document.getElementById(id);
            if (input) input.value = this.state.searchTerm;
        });
        
        // Sync grouping
        const groupSelect = document.getElementById('groupSelect');
        if (groupSelect) groupSelect.value = this.state.currentGrouping;
        
        // FIXED: Sync toggle label button state
        this.updateToggleLabelButton();
    }
    
    // CRITICAL FIX: Update toggle label button to match state
    updateToggleLabelButton() {
        console.log(`üè∑Ô∏è Updating toggle label button - showLabels: ${this.state.showLabels}`);
        
        const buttons = document.querySelectorAll('[onclick="toggleLabels()"]');
        buttons.forEach(btn => {
            const icon = btn.querySelector('i');
            if (icon) {
                // Update icon based on current state
                if (this.state.showLabels) {
                    icon.className = 'fas fa-tags';  // Labels are shown
                } else {
                    icon.className = 'fas fa-eye-slash';  // Labels are hidden
                }
            }
            
            // Update button title/tooltip
            btn.title = this.state.showLabels ? 'Hide Labels' : 'Show Labels';
        });
    }
    
    // Utility functions
    showLoading(show) {
        const overlay = document.getElementById('vizLoadingOverlay');
        if (show) {
            overlay.classList.remove('hidden');
            overlay.setAttribute('aria-hidden', 'false');
        } else {
            overlay.classList.add('hidden');
            overlay.setAttribute('aria-hidden', 'true');
        }
    }
}

// Global functions for UI controls
let visualization;

// Mobile-specific functions
function toggleMobileSearch() {
    const container = document.getElementById('mobileSearchContainer');
    const isVisible = container.classList.contains('active');
    
    if (isVisible) {
        container.classList.remove('active');
    } else {
        container.classList.add('active');
        setTimeout(() => {
            document.getElementById('mobileSearchInput')?.focus();
        }, 300);
    }
}

function toggleMobileControls() {
    const sliderGroup = document.getElementById('mobileSliderGroup');
    const isVisible = sliderGroup.style.display !== 'none';
    
    sliderGroup.style.display = isVisible ? 'none' : 'block';
    
    if (!isVisible) {
        sliderGroup.style.opacity = '0';
        sliderGroup.style.transform = 'translateY(-10px)';
        
        setTimeout(() => {
            sliderGroup.style.transition = 'all 0.3s ease';
            sliderGroup.style.opacity = '1';
            sliderGroup.style.transform = 'translateY(0)';
        }, 10);
    }
}

// Panel controls
function toggleVizPanel() {
    const panel = document.getElementById('vizControlPanel');
    const isMobile = window.innerWidth <= 768;
    
    if (isMobile) return;
    
    panel.classList.toggle('collapsed');
    localStorage.setItem('vizPanelCollapsed', panel.classList.contains('collapsed'));
}

// View control functions
function resetView() {
    if (!visualization) return;
    
    visualization.svg.transition()
        .duration(750)
        .ease(d3.easeCubicInOut)
        .call(
            visualization.zoom.transform,
            d3.zoomIdentity
        );
        
    visualization.saveState();
}

function fitToScreen() {
    if (!visualization) return;
    
    const bounds = visualization.getTreeBounds();
    const padding = visualization.isMobile ? 60 : 100;
    
    const scale = Math.min(
        (visualization.width - padding) / (bounds.width || 1),
        (visualization.height - padding) / (bounds.height || 1),
        3
    ) * 0.9;
    
    const centerX = bounds.x + bounds.width / 2;
    const centerY = bounds.y + bounds.height / 2;
    
    visualization.svg.transition()
        .duration(750)
        .ease(d3.easeCubicInOut)
        .call(
            visualization.zoom.transform,
            d3.zoomIdentity
                .translate(visualization.width / 2, visualization.height / 2)
                .scale(scale)
                .translate(-centerX, -centerY)
        );
        
    visualization.saveState();
}

function expandAll() {
    if (!visualization) return;
    
    visualization.root.descendants().forEach(d => {
        if (d._children) {
            d.children = d._children;
            d._children = null;
        }
    });
    
    visualization.updateVisualization();
    setTimeout(() => fitToScreen(), 500);
}

function collapseAll() {
    if (!visualization) return;
    
    visualization.root.descendants().forEach(d => {
        if (d.children && d.depth > 0) {
            d._children = d.children;
            d.children = null;
        }
    });
    
    visualization.updateVisualization();
    setTimeout(() => fitToScreen(), 500);
}

// FIXED: Complete toggle labels function
function toggleLabels() {
    if (!visualization) return;
    
    console.log(`üè∑Ô∏è Toggle labels called - current state: ${visualization.state.showLabels}`);
    
    // Toggle the state
    visualization.state.showLabels = !visualization.state.showLabels;
    
    console.log(`üè∑Ô∏è New label state: ${visualization.state.showLabels}`);
    
    // Update the button appearance
    visualization.updateToggleLabelButton();
    
    // Redraw labels based on new state
    if (visualization.state.showLabels) {
        visualization.drawLabels();
    } else {
        visualization.labelGroup.selectAll(".label").remove();
        visualization.labels = null;
    }
    
    // Save the state
    visualization.saveState();
    
    console.log(`‚úÖ Labels ${visualization.state.showLabels ? 'shown' : 'hidden'}`);
}

// Zoom controls
function zoomIn() {
    if (!visualization) return;
    
    visualization.svg.transition()
        .duration(300)
        .call(visualization.zoom.scaleBy, 1.4);
        
    visualization.saveState();
}

function zoomOut() {
    if (!visualization) return;
    
    visualization.svg.transition()
        .duration(300)
        .call(visualization.zoom.scaleBy, 0.7);
        
    visualization.saveState();
}

// Node info controls
function closeVizNodeInfo() {
    if (visualization) {
        visualization.closeNodeInfo();
    }
}

// Enhanced initialization
document.addEventListener('DOMContentLoaded', () => {
    console.log('üé® Initializing Enhanced Site Structure Visualization...');
    
    // Initialize visualization
    visualization = new SiteVisualization();
    
    // Apply saved panel state for desktop
    if (window.innerWidth > 768) {
        const panelCollapsed = localStorage.getItem('vizPanelCollapsed') === 'true';
        const panel = document.getElementById('vizControlPanel');
        
        if (panelCollapsed) {
            panel.classList.add('collapsed');
        } else {
            panel.classList.remove('collapsed');
        }
    }
    
    console.log('‚úÖ Enhanced Site Structure Visualization initialized!');
});

// Performance monitoring and cleanup
window.addEventListener('beforeunload', () => {
    if (visualization) {
        visualization.saveState();
        
        if (visualization.simulation) {
            visualization.simulation.stop();
        }
    }
});

// Error handling
window.addEventListener('error', (e) => {
    console.error('Visualization error:', e);
    
    const overlay = document.getElementById('vizLoadingOverlay');
    if (overlay && !overlay.classList.contains('hidden')) {
        overlay.classList.add('hidden');
    }
});
</script>
{% endblock %}